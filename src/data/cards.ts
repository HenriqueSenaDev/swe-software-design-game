import { CardPair } from "../types/cards";

export const cardPairs: CardPair[] = [
  {
    level: "easy",
    question: "O que é a decomposição no projeto de software?",
    answer: "Dividir um problema complexo em partes menores e independentes."
  },
  {
    level: "easy",
    question: "Como a abstração ajuda no projeto de software?",
    answer: "Simplifica o uso de partes complexas do sistema."
  },
  {
    level: "easy",
    question: "Por que a integridade conceitual é importante?",
    answer: "Garante a coerência e consistência no sistema."
  },
  {
    level: "easy",
    question: "O que é a integridade conceitual?",
    answer: "Coerência e consistência nas funcionalidades e interfaces de um sistema."
  },
  {
    level: "easy",
    question: "Qual é a vantagem do ocultamento de informação?",
    answer: "Facilita desenvolvimento paralelo e manutenção."
  },
  {
    level: "easy",
    question: "O que é um acoplamento ruim?",
    answer: "Dependência forte entre classes que dificulta mudanças."
  },
  {
    level: "easy",
    question: "Qual é a vantagem de ter interfaces pequenas?",
    answer: "Elas são mais fáceis de entender e implementar corretamente."
  },
  {
    level: "easy",
    question: "Como uma boa integridade conceitual ajuda?",
    answer: "Melhora a usabilidade e compreensão do sistema."
  },
  {
    level: "easy",
    question: "Qual é o benefício do ocultamento de informação?",
    answer: "Facilita mudanças e desenvolvimento paralelo."
  },
  {
    level: "medium",
    question: "O que significa uma classe ser coesa no projeto de software?",
    answer: "A classe deve ter um único propósito ou função."
  },
  {
    level: "medium",
    question: "O que define o Princípio da Responsabilidade Única?",
    answer: "Cada classe deve ter uma única razão para ser modificada."
  },
  {
    level: "medium",
    question: "O que é o Princípio da Segregação de Interfaces?",
    answer: "Interfaces devem ser específicas e não carregar métodos desnecessários."
  },
  {
    level: "medium",
    question: "Como o Princípio de Demeter pode simplificar o código?",
    answer: "Reduz a dependência entre objetos, tornando o código mais modular."
  },
  {
    level: "medium",
    question: "O que o Princípio de Inversão de Dependências sugere?",
    answer: "Depende de abstrações, não de implementações concretas."
  },
  {
    level: "medium",
    question: "Quais são os instrumentos oferecidos por linguagens de programação para a criação de abstrações?",
    answer: "Funções, classes, interfaces, pacotes e bibliotecas."
  },
  {
    level: "medium",
    question: "Por que a decomposição de um problema é importante na Engenharia de Software?",
    answer: "Porque ajuda a combater a complexidade dos sistemas modernos de software."
  },
  {
    level: "medium",
    question: "Quais são os três objetivos principais no projeto de software?",
    answer: "Decompor o problema, implementar independentemente, criar abstrações."
  },
  {
    level: "medium",
    question: "O que o analisador léxico faz?",
    answer: "O analisador léxico lê o arquivo de entrada e divide-o em tokens (como if, for, while, x, +, etc.)."
  },
  {
    level: "hard",
    question: "Qual é a principal vantagem do padrão Adapter?",
    answer: "Permite que sistemas com interfaces diferentes interajam."
  },
  {
    level: "hard",
    question: "O que faz o padrão Iterador?",
    answer: "Padroniza a navegação sobre uma estrutura de dados."
  },
  {
    level: "hard",
    question: "Qual é a função principal do Singleton?",
    answer: "Garante uma única instância de uma classe."
  },
  {
    level: "hard",
    question: "O que faz o padrão Fábrica?",
    answer: "Encapsula a criação de objetos."
  },
  {
    level: "hard",
    question: "Quando não usar o padrão Fábrica?",
    answer: "Se não for necessário criar objetos de tipos diferentes."
  },
  {
    level: "hard",
    question: "O que faz o padrão Fachada?",
    answer: "Fornece uma interface simplificada para um subsistema."
  },
  {
    level: "hard",
    question: "O que é um Proxy?",
    answer: "Representa ou substitui um objeto real."
  },
  {
    level: "hard",
    question: "Como medir a coesão de uma classe?",
    answer: "Olhe se a classe realiza uma única função bem."
  },
  {
    level: "hard",
    question: "O que faz o padrão Decorador?",
    answer: "Adiciona funcionalidades a um objeto dinamicamente."
  },
];